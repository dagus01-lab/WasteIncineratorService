/** Modello per l'architettura logica dello SPRINT1 del WasteIncineratorService */

System waste_incinerator_service

//Messaggio per la ricezione di un nuovo RP
Dispatch arrived_RP : arrived_RP(N) "command that simulate the arrival of new RP"

//Messaggio per notificare lo stato del Incinerator al WIS
Dispatch statoIncinerator : statoIncinerator(N)  "Incinerator's burning status info"

//Messaggi per la gestione del burning dell'Incinerator
Dispatch activationCommand : activationCommand(N) "command that turns the incinerator on"
Dispatch startBurning : startBurning(N) "command that makes the incinerator start burning the next RP"
Dispatch rpInBurnin : rpInBurnin(N)  "command that makes the wis start the incinerator"
Event 	 endBurning : endBurning(N) "event generated by the incinerator when the burning process is terminated"

//Messaggi per muovere il BasicRobot
Dispatch cmd    : cmd( MOVE )  "MOVE = a|d|l|r|h   "
Dispatch end       	: end(ARG)
Request step       : step(TIME)	
Reply stepdone     : stepdone(V)                 for step
Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

//Definizione dei tre contesti (service, basicRobot e RaspBerry)
Context ctx_waste_incinerator_service ip [host="localhost" port=8125]
//Context ctxbasicrobot ip [host="127.0.0.1" port=8120]
//Context ctxrasp ip[host="127.0.0.2" port=8122]

//Attore "esterno" BasicRobot
//ExternalQActor basicrobot context ctxbasicrobot

//Attore WIS
QActor wis context ctx_waste_incinerator_service{
	
	State s0 initial{
		delay 500
		println("$name STARTS") color green
		
		forward incinerator -m activationCommand : activationCommand(1)
	}
	Goto waitingRP
	
	//Stato che simula l'attesa di un nuovo RP nel WasteStorage
	State waitingRP{
		println("Waiting for a new RP...") color green
	}
	Transition t0 whenMsg arrived_RP ->  handleRP
				
	//Stato per gestire l'arrivo di un nuovo RP nel WasteStorage
	State handleRP{
		println("New RP is arrived") color green
		forward oprobot -m arrived_RP : arrived_RP(1)
	}
	
	Transition t0 whenMsg rpInBurnin -> handleRPInBurnin
	
	State handleRPInBurnin{
		println("An RP is ready to be burnt") color green
		forward incinerator -m startBurning : startBurning(1)
		//dice alla GUI che l'inceneritore sta bruciando
	}
	
	Transition t0 whenEvent endBurning -> handleEndBurning
	
	//Stato per gestire l'evento di endBurning
	State handleEndBurning{
		//dice alla GUI che l'inceneritore ha finito di bruciare
		println("Incinerator has finished to burn") color green
	}
	Goto waitingRP
}

//Attore OpRobot
QActor oprobot context ctx_waste_incinerator_service{
	State s0 initial{
		println("$name STARTS") color yellow
		//place robot in HOME
	}
	Goto startHome
	State startHome{
		//move the robot in HOME position
		println("$name is in HOME position") color yellow
	}
	Transition t0 whenMsg arrived_RP -> takeRP
	State takeRP{
		//take an RP and bring it to BURNIN port
		forward wis -m rpInBurnin : rpInBurnin(1)
		println("An RP is in BURNIN port") color yellow
		//then, return HOME
	}
	Transition t0 whenEvent endBurning -> bringAshOut
	State bringAshOut{
		//take ash from BURNOUT port and bring it to ashStorage
		println("The ash has been taken out") color yellow
	}
	Goto startHome
}

//Attore Incinerator
QActor incinerator context ctx_waste_incinerator_service{
	[# val BTIME = 10000L; var stato = 0; #]
	
	State s0 initial{
		println("$name STARTS") color red
	}
	Transition t0 whenMsg activationCommand -> turnOn
	
	State turnOn {
		println("Incinerator is on. Waiting for RPs to burn...") color red
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
	
	//Stato per gestire l'inizio di burning
	State handleStartBurning{
		println("Incinerator is burning...") color red
		[# stato = 1 #]
		updateResource [# "statoIncinerator(1)" #] //aggiorno gli Observer collegati
	}
	Transition t0 whenTimeVar BTIME -> handleEndBurning
	
	//Stato per gestire la fine di burning
	State handleEndBurning{
		//println("Incinerator has finished to burn") color red
		emit endBurning : endBurning(1) //emette il segnale di fine burning
		[# stato = 0 #]
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
}

//attore mock che simula la presenza di RP nel WasteStorage
QActor scalemock context ctx_waste_incinerator_service{
	State s0 initial {
		println("$name STARTS") color black
	}
	Transition t0 whenTime 1000 -> simulateRP
	State simulateRP {
		//l'attore simula l'arrivo di un RP dopo 1 secondo
		forward wis -m arrived_RP : arrived_RP(1)
		delay 3000
		forward wis -m arrived_RP : arrived_RP(1)
		delay 8000
		forward wis -m arrived_RP : arrived_RP(1)
		
	}
}

//Attore MonitoringDevice
/*QActor monitoring_device_mok context ctxrasp{
	State s0 initial{
		println("$name STARTS") color yellow
		
		[# var ashContainerIsFull = false; #]
	}
}
*/