/** Modello per l'architettura logica dello SPRINT1 del WasteIncineratorService */

System waste_incinerator_service

//Messaggio per la ricezione di un nuovo RP
Dispatch arrived_RP : arrived_RP(N) "command that simulate the arrival of new RP"

//Messaggio per notificare lo stato del Incinerator al WIS
Dispatch statoIncinerator : statoIncinerator(N)  "Incinerator's burning status info"

//Messaggi per la gestione del burning dell'Incinerator
Dispatch activationCommand : activationCommand(N) "command that turns the incinerator on"
Dispatch startBurning : startBurning(N) "command that makes the incinerator start burning the next RP"
Event 	 endBurning : endBurning(N) "event generated by the incinerator when the burning process is terminated"

//Messaggi per muovere il BasicRobot
Dispatch cmd    : cmd( MOVE )  "MOVE = a|d|l|r|h   "
Request step       : step(TIME)	
Reply stepdone     : stepdone(V)                 for step
Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

//Definizione dei tre contesti (service, basicRobot e RaspBerry)
Context ctx_waste_incinerator_service ip [host="localhost" port=8125]
//Context ctxbasicrobot ip [host="127.0.0.1"  port=8120] 
//Context ctxrasp ip[host="127.0.0.2" port=8122]

//Attore "esterno" BasicRobot
//ExternalQActor basicrobot context ctxbasicrobot

//Attore WIS
QActor wis context ctx_waste_incinerator_service{
	[# var RP = 0 ; var statoIncinerator = 0 #]
	
	State s0 initial{
		delay 500
		println("$name STARTS")
		//Invia comando di attivazione del Incinerator
		forward incinerator -m activationCommand : activationCommand(1)
		//Si mette ad osservare lo stato del Incinerator
		observeResource incinerator msgid statoIncinerator
	}
	Goto waitingRP
	
	//Stato che simula l'attesa di un nuovo RP nel WasteStorage
	State waitingRP{
		println("Waiting new RP...")
		delay 10000
		autodispatch arrived_RP : arrived_RP(1) //automessaggio che simula l'arrivo di un nuovo RP
	}
	Transition t0 whenEvent endBurning -> handleEndBurning
				   whenMsg statoIncinerator -> handleUpdateStatoIncinerator
				   whenMsg arrived_RP ->  handleRP
				
	//Stato per gestire l'arrivo di un nuovo RP nel WasteStorage
	State handleRP{
		println("New RP is arrived")
		[# RP++ #]
		println("RPs in WasteStorage: $RP")
		//Se l'Incinerator non sta bruciando, chiedo di bruciare un RP
		if [# statoIncinerator == 0 && RP >= 1 #]
		{
			println("Incinerator is not burning and an RP is available. WIS send startBurning.")
			forward incinerator -m startBurning : startBurning(1)
		}
	}
	Goto waitingRP
	
	//Stato per aggiornare lo stato del Incinerator
	State handleUpdateStatoIncinerator{
		onMsg( statoIncinerator : statoIncinerator(N)){
			[# statoIncinerator = payloadArg(0).toInt() #]
		}
	}
	Goto waitingRP
	
	//Stato per gestire l'evento di endBurning
	State handleEndBurning{
		println("Incinerator has finished to burn")
		[# statoIncinerator = 0 #]
	}
	Goto waitingRP
}

//Attore Incinerator
QActor incinerator context ctx_waste_incinerator_service{
	[# val BTIME = 10000L; var stato = 0; #]
	
	State s0 initial{
		println("$name STARTS") color red
	}
	Transition t0 whenMsg activationCommand -> turnOn
	
	State turnOn {
		println("Incinerator is on. Waiting for RPs to burn...") color red
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
	
	//Stato per gestire l'inizio di burning
	State handleStartBurning{
		println("Incinerator is burning...") color red
		[# stato = 1 #]
		updateResource [# "statoIncinerator(1)" #] //aggiorno gli Observer collegati
	}
	Transition t0 whenTimeVar BTIME -> handleEndBurning
	
	//Stato per gestire la fine di burning
	State handleEndBurning{
		println("Incinerator has finished to burn") color red
		emit endBurning : endBurning(1) //emette il segnale di fine burning
		[# stato = 0 #]
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
}


//Attore MonitoringDevice
/*QActor monitoring_device_mok context ctxrasp{
	State s0 initial{
		println("$name STARTS") color yellow
		
		[# var ashContainerIsFull = false; #]
	}
}
*/