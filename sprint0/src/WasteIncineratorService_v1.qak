/** Seconda versione del modello per l'analisi dei requisiti del problema WasteIncineratorService */

System waste_incinerator_service

//Messaggi per la gestione del burning dell'Incinerator
Dispatch activationCommand : activationCommand(N) "command that turns the incinerator on"
//Dispatch startBurning : startBurning(N) "command that makes the incinerator start burning the next RP"
Event 	 endBurning : endBurning(N) "event generated by the incinerator when the burning process is terminated"

//Messaggi per muovere il BasicRobot
Dispatch cmd    : cmd( MOVE )  "MOVE = a|d|l|r|h   "
Request step       : step(TIME)	
Reply stepdone     : stepdone(V)                 for step
Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

//Definizione dei tre contesti (service, basicRobot e RaspBerry)
Context ctx_waste_incinerator_service ip [host="localhost" port=8125]
Context ctxbasicrobot ip [host="127.0.0.1"  port=8120] 
Context ctxrasp ip[host="127.0.0.2" port=8122]

//Attore "esterno" BasicRobot
ExternalQActor basicrobot context ctxbasicrobot

//Attore WIS
QActor wis context ctx_waste_incinerator_service{
	State s0 initial{
		println("$name STARTS")
		//Invia comando di attivazione del Incinerator
		forward incinerator -m activationCommand : activationCommand(1)
	}
	Transition t0 whenEvent endBurning -> handleEndBurning
	
	//Stato per gestire l'evento di endBurning
	State handleEndBurning{
		println("Incinerator has finished to burn")
	}
	Transition t0 whenEvent endBurning -> handleEndBurning
}

//Attore Incinerator
QActor incinerator context ctx_waste_incinerator_service{
	State s0 initial{
		println("$name STARTS") color red
		
		[# val BTIME = 10000L; var stato = 0; #]
	}
	Transition t0 whenMsg activationCommand -> turnOn
	
	State turnOn {
		println("Incinerator is on. Waiting for RPs to burn...") color red
	}
	
	//Transition t0 whenMsg startBurning -> handleStartBurning
	
	//Stato per gestire l'inizio di burning
	State handleStartBurning{
		println("Incinerator is burning...") color red
	}
	Transition t0 whenTimeVar BTIME -> handleEndBurning
	
	//Stato per gestire la fine di burning
	State handleEndBurning{
		println("Incinerator has finished to burn") color red
		emit endBurning : endBurning(1) //emette il segnale di fine burning
	}
	//Transition t0 whenMsg startBurning -> handleStartBurning
}


//Attore MonitoringDevice
QActor monitoring_device context ctxrasp{
	State s0 initial{
		println("$name STARTS") color yellow
	}
}
