/** Modello per l'architettura logica dello SPRINT2 del WasteIncineratorService */
System waste_incinerator_service

//Messaggio per la ricezione di un nuovo RP
Event num_RP : num_RP(N) "event that simulates the arrival of a new RP"
Dispatch arrived_RP : arrived_RP(N) 

//Messaggio per notificare lo stato del Incinerator al WIS
Event statoIncinerator : statoIncinerator(N)  "Incinerator's burning status info: 0 is not burning, 1 otherwise"
Dispatch incineratorState: incineratorState(N)
//Messaggi per la gestione del burning dell'Incinerator
Dispatch activationCommand : activationCommand(N) "command that turns the incinerator on"
Dispatch startBurning : startBurning(N) "command that makes the incinerator start burning the next RP"
Dispatch rpInBurnin : rpInBurnin(N)  "command that makes the wis start the incinerator"
Event 	 endBurning : endBurning(N) "event generated by the incinerator when the burning process is terminated"
 
Dispatch waitingForNewRPs : waitingForNewRPs(N) "observable state that indicates whether the WIS is ready to receive and handle new RPs"
Event opRobotState:opRobotState(N)
Event opRobotJob:opRobotJob(N)
Event alarm : alarm(X)

//Messaggio per notificare la fine del percorso del OpRobot.
Dispatch newAshes : newAshes(N) "command that simulate the arrival of new RP's ashes"

//Messaggio per notificare lo stato del AshStorage al WIS
Dispatch ashesLevel : ashesLevel(N) "Event that simulates the level of the ashstorage container"
Event statoAshStorage : statoAshStorage(N, D)  "AshStorage info: 0 is not empty, 1 otherwise"

//Messaggio per notificare al wis che il monitoringDevice non sta più mandando aggiornamenti o che è ripartito
Dispatch monitoringDeviceOff:monitoringDeviceOff(N) "message that represents the level of the ash storage (1 if it is up, 0 otherwise)"

//Messaggi per ingaggiare e muovere il BasicRobot
Request engage        : engage(OWNER, STEPTIME)	 
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage 
Dispatch disengage    : disengage(ARG) 

Request moverobot    :  moverobot(TARGETX, TARGETY)   
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot

//Definizione dei contesti
Context ctx_waste_incinerator_service ip [host="localhost" port=8125]
Context ctxbasicrobot ip [host="127.0.0.1" port=8020] 

//Attori esterni al WIS
ExternalQActor basicrobot context ctxbasicrobot

//--------------------------------Attori WIS-proxy-----------------------------------------------------------
QActor wisscaleproxy context ctx_waste_incinerator_service withobj config using "WISConfigReader.loadWISConfig(\"wis_conf.json\")"{
	import "main.resources.WISConfigReader"
	import "main.resources.WISConfig" 
	[#
		var RPs = 0;
		var previous_RPs = 0;
		var broker_url = config.broker_url
	#]
	State s0 initial{
		connectToMqttBroker "$broker_url" clientid "wisscaleproxynat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "wisscaleproxynat"
 		println("$name | CREATED  (and connected to mosquitto) ... ") color magenta
 		subscribe "wisinfo"
		//si mette ad osservare lo stato del AshStorage fornito dal MonitoringDevice
	}
	Transition t0 whenEvent num_RP -> handle_new_RP
	State handle_new_RP{
		onMsg(num_RP:num_RP(N)){
			[#
				try{
					RPs = payloadArg(0).toInt()
					#]
					if[#RPs >= 0 && RPs != previous_RPs#]{
						forward raspberryinfocontroller -m arrived_RP:arrived_RP($RPs)
						[#previous_RPs = RPs#]
					}
					[#
				} catch(e:Exception){
					#]println("$name received invalid payload:${payloadArg(0)}") color red[#
				}
			#]
		}
	}
	Transition t0 whenEvent num_RP -> handle_new_RP
}

QActor wismonitoringdeviceproxy context ctx_waste_incinerator_service withobj config using "WISConfigReader.loadWISConfig(\"wis_conf.json\")"{
	import "main.resources.WISConfigReader"
	import "main.resources.WISConfig" 

	[#
		var Status = -1;
		var previousStatus = -1;
		var broker_url = config.broker_url
	#]
	State s0 initial{
		connectToMqttBroker "$broker_url" clientid "wismonitoringdeviceproxynat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "wismonitoringdevicenat"
 		println("$name | CREATED  (and connected to mosquitto) ... ") color cyan
 		delay 1000
 		subscribe "wisinfo"
		//si mette ad osservare lo stato del AshStorage fornito dal MonitoringDevice
	}
	Goto wait
	State wait{
		
	}
	Transition t0 	whenTime 15000 -> handleTimeoutExpired
					whenEvent statoAshStorage -> handleUpdateStatoAshStorage
	State handleUpdateStatoAshStorage{
		onMsg(statoAshStorage:statoAshStorage(N, D)){
			[#
				try{
					var Status = payloadArg(0).toInt()
			#]
			if[#Status>=0 && Status != previousStatus#]{
				forward raspberryinfocontroller -m ashesLevel:ashesLevel($Status)
			}
			[#	
				previousStatus=Status
				}catch(e:Exception){
					#]println("$name received invalid payload:${payloadArg(0)}") color red[#
				}
			#]
			
		}
	}
	Goto wait
	
	State handleTimeoutExpired{
		[#previousStatus=-1#]
		forward raspberryinfocontroller -m monitoringDeviceOff:monitoringDeviceOff(1)
	}
	Goto wait
}

QActor raspberryinfocontroller context ctx_waste_incinerator_service{
	[#
		var RPs = 0;
		var AshesLevel = 0;
		var previousAshesLevel = 0;
		var wisReady = 0;
		var monitoringDeviceRunning = 0;
	#]
	State s0 initial{
		delay 1000
		println("$name | RUNS") color gray
		observeResource wis msgid waitingForNewRPs
	}
	Goto wait
	State wait{
		//println("$name | mdrunning=$monitoringDeviceRunning, wisReady=$wisReady, RPs=$RPs, AshesLevel=$AshesLevel")
		if[#monitoringDeviceRunning == 1 && wisReady == 1 && RPs>0 && AshesLevel==0#]{
			forward wis -m arrived_RP:arrived_RP(1)
			[#wisReady = 0#]
		}
		else{
			if[#wisReady == 1 && previousAshesLevel != AshesLevel#]{
				forward wis -m ashesLevel:ashesLevel($AshesLevel)
				[#previousAshesLevel = AshesLevel#]
			}
		}
	}
	Transition t0 whenMsg monitoringDeviceOff -> handleMonitoringDeviceOff
				whenMsg ashesLevel -> handleNewAshesLevel
				whenMsg arrived_RP -> handleNewScaleState
				whenMsg waitingForNewRPs -> handleWISReady
				
	State handleMonitoringDeviceOff{
		[#monitoringDeviceRunning=0#]
		println("$name | Waiting for monitoringDevice to run again..") color magenta
	}
	Goto wait
	State handleNewScaleState{
		onMsg(arrived_RP:arrived_RP(N)){
			println("$name received new RP") color magenta
			[#RPs = payloadArg(0).toInt()#]
		}
	}
	Goto wait
	State handleWISReady{
		[#wisReady = 1#]
		println("$name | WIS ready to take new RPs")
	}
	Goto wait
	State handleNewAshesLevel{
		onMsg(ashesLevel:ashesLevel(N)){
			[#
			AshesLevel = payloadArg(0).toInt()
			monitoringDeviceRunning=1
			#]
		}
	}
	Goto wait
	
}

//--------------------------------Attore WIS-----------------------------------------------------------------
QActor wis context ctx_waste_incinerator_service{
	[# 
		var AshStorageStatus = 0 
	#]
	
	State s0 initial{
		delay 1000
		println("$name STARTS") color green
		//mando messaggio di attivazione del Incinerator
		forward incinerator -m activationCommand : activationCommand(1)
		delay 1000
	}
	Goto waitingRP
	//Stato che simula l'attesa di un nuovo RP nel WasteStorage
	State waitingRP{
		println("$name waiting for new RPs") color green
		updateResource[#"waitingForNewRPs(1)"#]
	}
	Transition t0 whenMsg ashesLevel-> handleUpdateAshesLevel
				  whenMsg arrived_RP ->  handleRP
	
	//Stato per gestire l'arrivo di un nuovo RP nel WasteStorage
	State handleRP{
		println("New RP is arrived") color green
		//notifico il robot che un nuovo RP è disponibile
		forward oprobot -m arrived_RP : arrived_RP(1)
	}
	Transition t0 whenMsg rpInBurnin -> handleRPInBurnin
	
	//Stato per gestire l'arrivo del opRobot nella porta di BURNIN del Incinerator
	State handleRPInBurnin{
		println("An RP is ready to be burnt") color green
		//mando messaggio di inizio burning al Incinerator
		forward incinerator -m startBurning : startBurning(1)
	}
	Transition t0 whenEvent endBurning -> handleEndBurning
	
	//Stato per gestire l'evento di endBurning
	State handleEndBurning{
		println("Incinerator has finished to burn") color green
	}
	Transition t0 whenMsg newAshes -> endRoute
	
	//Stato per gestire la "fine del giro" di scarico del robot
	State endRoute{
		println("$name OpRobot has finished its route") color green
		//se entro 1 secondo non ricevo aggiornamenti sullo stato del AshStorage, 
		//allora considero di poter bruciare un nuovo RP
	}
	
	
	
	Goto waitingRP
			
	//Stato per gestire l'aggiornamento dello stato del AshStorage
	State handleUpdateAshesLevel{
		//printCurrentMessage color green
		onMsg(ashesLevel : ashesLevel(N)){
			[# AshStorageStatus = payloadArg(0).toInt()#]
			println("AshStorageStatus: $AshStorageStatus") color green
		}
	}
	Goto waitingRP if [# AshStorageStatus == 0 #] else waitingAshesToBeRemoved
	
	//Stato per gestire l'attesa che la cenere nel AshStorage sia rimossa per poter bruciare nuovi RPs
	State waitingAshesToBeRemoved{
		println("WIS is waiting for an operator to remove ashes in AshStorage...") color green
	}
	Transition t0 whenMsg ashesLevel -> handleUpdateAshesLevel
}
//-----------------------------------------------------------------------------------------------------------

//----------------------------------------Attore OpRobot-----------------------------------------------------
QActor oprobot context ctx_waste_incinerator_service withobj config using "WISConfigReader.loadWISConfig(\"wis_conf.json\")"{
	import "main.resources.WISConfigReader"
	import "main.resources.WISConfig" 
	[#	
		//TODO: evitare di creare variabili per poter usare direttamente gli attributi di config nei messaggi.
		//		Il problema al momento sta nel fatto che il payload dei messaggi nel modello qak non può contenere il carattere "."
		var HOMEx = config.HOMEx
		var HOMEy = config.HOMEy
		var WASTEINx = config.WASTEINx
		var WASTEINy = config.WASTEINy
		var BURNINx = config.BURNINx
		var BURNINy = config.BURNINy
		var BURNOUTx = config.BURNOUTx
		var BURNOUTy = config.BURNOUTy
		var ASHOUTx = config.ASHOUTx
		var ASHOUTy = config.ASHOUTy
		var StepTime = config.step_time
		var broker_url = config.broker_url
	#]
	State s0 initial{
		println("$name STARTS") color yellow
		connectToMqttBroker "$broker_url" clientid "oprobotnat"
		println("$name connected to MQTT server")
	}
	Goto engage
	
	//Stato per provare ad "ingaggiare" il BasicRobot
	State engage{
		println("$name | $MyName engaging ... ") color yellow 
		request basicrobot -m engage : engage($MyName,$StepTime) //pc Emanuele 112, fisso Gabriele 260, portatile Gabriele 330
	}
	Transition t0 whenTime 1000 -> noResponse
				  whenReply engagedone   -> waitingWorking
 	              whenReply engagerefused -> end
 	          
 	//stato che rappresenta l'assenza di risposta da parte del basicrobot
 	State noResponse{
 		println("BasicRobot did not answer!") color yellow
 	}
 	Goto end
	
	//Stato che rappresenta il robot in attesa di lavoro
	State waitingWorking{
		publish "wisinfo" -m opRobotState:opRobotState(HOME)
		publish "wisinfo" -m opRobotJob:opRobotJob(Waiting_for_an_RP)
		println("$name is in HOME position waiting for working") color yellow
	}
	Transition t0 whenMsg arrived_RP -> takeRP
	
	//Stato che rappresenta il robot che va a recuperare un RP dal WasteStorage
	State takeRP{
		publish "wisinfo" -m opRobotJob:opRobotJob(Going_to_WASTEIN)
		println("OpRobot is going to take an RP..") color yellow
		request basicrobot -m moverobot:moverobot($WASTEINx,$WASTEINy)
	}
	Transition t0 whenReply moverobotdone -> bringRPtoBURNIN
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che porta l'RP recuperato dal WasteStorage nella porta BURNIN
	State bringRPtoBURNIN{
		delay 2000 //simulazione del prelievo di un RP dal WasteStorage
		request basicrobot -m moverobot:moverobot($BURNINx, $BURNINy) 
		publish "wisinfo" -m opRobotState:opRobotState(WASTEIN)
		publish "wisinfo" -m opRobotJob:opRobotJob(Going_to_BURNIN)
	}
	Transition t0 whenReply moverobotdone -> returnHOME
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta lo spostamento in HOME del robottino una volta che l'RP è stato messo nell'inceneritore
	State returnHOME{
		delay 2000 //simulazione del rilascio di un RP in BURNIN
		forward wis -m rpInBurnin : rpInBurnin(1)
		println("An RP is in BURNIN port") color yellow
		request basicrobot -m moverobot:moverobot($HOMEx, $HOMEy)
		publish "wisinfo" -m opRobotState:opRobotState(BURNIN)
		publish "wisinfo" -m opRobotJob:opRobotJob(Returning_HOME)
		//then, return HOME
	}
	Transition t0 whenReply moverobotdone -> waitingForIncinerator
				  whenReply moverobotfailed -> exit
				 
	//Stato che rappresenta l'attesa del incinerator che sta bruciando
	State waitingForIncinerator{
		println("Waiting for incinerator to finish its job") color yellow
		publish "wisinfo" -m opRobotState:opRobotState(HOME)
		publish "wisinfo" -m opRobotJob:opRobotJob(Waiting_for_incinerator_to_finish_its_job)
	}
	Transition t0 whenEvent endBurning -> takeAshFromBURNOUT
	
	//Stato che rappresenta il robot che preleva la cenere dalla porta BURNOUT
	State takeAshFromBURNOUT{
		request basicrobot -m moverobot:moverobot($BURNOUTx, $BURNOUTy)
		publish "wisinfo" -m opRobotJob:opRobotJob(Going_to_take_ashes_from_BURNOUT)
	}
	Transition t0 whenReply moverobotdone -> bringAshtoASHOUT
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che va a depositare la cenere raccolta dall'inceneritore
	State bringAshtoASHOUT{
		delay 2000 //simulo il prelievo della cenere da BURNOUT
		request basicrobot -m moverobot:moverobot($ASHOUTx, $ASHOUTy)
		publish "wisinfo" -m opRobotState:opRobotState(BURNOUT)
		publish "wisinfo" -m opRobotJob:opRobotJob(Going_to_take_out_ashes_to_ASHOUT)
	}
	Transition t0 whenReply moverobotdone -> restartJob 
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che torna in HOME dopo aver scaricato le ceneri nell'AshStorage
	State restartJob{
		delay 2000 //simulo lo scaricamento della cenere
		println("The ash has been taken out") color yellow
		//mando notifica di nuova cenere
		forward wis -m newAshes : newAshes(1)
		request basicrobot -m moverobot:moverobot($HOMEx, $HOMEy)  
		publish "wisinfo" -m opRobotState:opRobotState(ASHOUT)
		publish "wisinfo" -m opRobotJob:opRobotJob(Returning_HOME)  
	}
	Transition t0 whenMsg arrived_RP -> takeRpBeforeFinishPlan
				  whenReply moverobotdone -> waitingWorking
				  whenReply moverobotfailed -> exit
	
	State takeRpBeforeFinishPlan{
		println("A new RP has arrived before OpRobot returned HOME") color yellow
		delay 500
		emit alarm:alarm(1) 
	}
	Transition t0 whenReply moverobotdone -> testko
				  whenReply moverobotfailed -> takeRP
	
	State testko{
		println("BasicRobot ignored alarm!!") color yellow
	}
	Goto takeRP
	
	//Stato di fine, nel caso l'engage del BasicRobot non fosse andata a buon fine
	State end{
		println("$name | ENDS ") color yellow
	}
	
	State exit{
		println("$name has been terminated") color yellow
		publish "wisinfo" -m opRobotState:opRobotState(FAILURE)
		publish "wisinfo" -m opRobotJob:opRobotJob(Failed_to_complete_path)
	}
}
//-----------------------------------------------------------------------------------------------------------

//---------------------------------Attore Incinerator--------------------------------------------------------
QActor incinerator context ctx_waste_incinerator_service withobj config using "WISConfigReader.loadWISConfig(\"wis_conf.json\")" {
	import "main.resources.WISConfigReader"
	import "main.resources.WISConfig" 
	[#
		var BTIME = config.incineration_duration
		var broker_url = config.broker_url
	#]
	State s0 initial{
		delay 1000
		println("$name STARTS") color red 
		connectToMqttBroker "$broker_url" clientid "incineratornat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "incineratornat" 
 		println("$name | CREATED  (and connected to mosquitto) ... ") color green
 		publish "wisinfo" -m statoIncinerator:statoIncinerator(OFF)
	}
	Transition t0 whenMsg activationCommand -> turnOn
	
	State turnOn {
		println("Incinerator is on. Waiting for RPs to burn...") color red
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
	
	//Stato per gestire l'inizio di burning
	State handleStartBurning{
		println("Incinerator is burning...") color red
		publish "wisinfo" -m statoIncinerator:statoIncinerator(BURNING)
	}
	Transition t0 whenTimeVar BTIME -> handleEndBurning
	
	//Stato per gestire la fine di burning
	State handleEndBurning{
		emit endBurning : endBurning(1) //emette il segnale di fine burning
		publish "wisinfo" -m statoIncinerator:statoIncinerator(OFF)
	}
	Transition t0 whenMsg startBurning -> handleStartBurning   
}
//-----------------------------------------------------------------------------------------------------------

/*
//-----------------------Attore mock che simula il comportamento della Scale---------------------------------
QActor scalemock context ctx_waste_incinerator_service{
	State s0 initial {
		println("$name STARTS") color black
	}//-----------------------------------------------------------------------------------------------------------
	Transition t0 whenTime 1000 -> simulateRP //l'attore simula l'arrivo di un RP dopo 1 secondo
	
	State simulateRP {
		delay 5000
		updateResource[#"arrived_RP(1)"#]
		//delay 38000
		//forward wis -m arrived_RP : arrived_RP(1)
	}
	Goto simulateRP
}

//-----------------------------------------------------------------------------------------------------------

//------------------------Attore mok che simula il comportamento del MonitoringDevice------------------------
QActor monitoring_device_mok context ctx_waste_incinerator_service{
	[# var ashLevel = 3; val MAX_LEVEL = 4;  //livello delle cenere sotto forma di numero di RP bruciati
	 var statoAshStorage=0; #]
	State s0 initial{
		println("$name STARTS") color yellow
	}Goto emitState
	
	State emitState{
		updateResource [# "statoAshStorage(0)" #]
		delay 2000
	}
	Transition t0 whenMsg newAshes -> handleAshes
	
	//Stato per gestire l'arrivo di nuova cenere nel container
	State handleAshes{
		[# ashLevel ++ #]
		//Se il livello della cenere = MAX_LEVEL, allora non posso bruciare altri RP
		if [# ashLevel == MAX_LEVEL #]
		{
			println("AshStorage is full. It is not possible to burn new RPs.") color yellow
			updateResource [# "statoAshStorage(1)" #] //aggiorno gli Observer collegati
		}
		else
		{
			updateResource [# "statoAshStorage(0)" #] //aggiorno gli Observer collegati
		}
	}
	Transition t0 whenTime 40000   -> simulateRemoveAshes
				  whenMsg newAshes -> handleAshes
				  
	//Stato per simulare la svuotamento del container di cenere
	State simulateRemoveAshes{
		println("Removed ashes from AshStorage. Now the container is empty.") color yellow
		[# ashLevel = 0 #]
		updateResource [# "statoAshStorage(0)" #] //aggiorno gli Observer collegati
	}
	Transition t0 whenMsg newAshes -> handleAshes
}
//-----------------------------------------------------------------------------------------------------------
*/
