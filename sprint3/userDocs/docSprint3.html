<!DOCTYPE html>
<head>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css" crossorigin="anonymous">
		<script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"crossorigin="anonymous"></script> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/code.css">
        <!-- <script type="text/javascript" src="./commons/resources/scripts/myScripts.js"></script> -->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}

.slidekp{
    background-color: hsl(332, 77%, 86%);
    border-radius: 10px;
    border: 1px solid blue;
    font-size: 18px; 
    font-weight: bold;
    line-height: 1.5;
    padding: 3px
  } 
</style>

<title>Documento Sprint3</title>
</head>

<body>
<div id="top">
	<h1> WASTE INCINERATOR SERVICE - Sprint 3 </h1>
</div>

<div class="body"> 
<h2>Introduzione</h2>
<p>
Un'azienda intende realizzare un <b>WasteIncineratorService</b> per trattare i rifiuti bruciandoli 
e necessita di un servizio di sistema software (WIS) che controlli un robot (chiamato OpRobot) per spostare i rifiuti.
</p>

<h2>Requisiti</h2>
<p>Il seguente link porta al documento dei requisiti fornito dal
cliente. <br/>
<a href="TemaFinale24.html">Documento requisiti</a> 
</p>

<h2>Sprint precedente</h2>
<p>Il seguente link porta al documento dello SPRINT precedente, nel
quale si sono sviluppati il MonitoringDevice e la Scale.<br/>
<a href="../../sprint2/userDocs/docSprint2.html">SPRINT 2</a> 
</p>

<h4>Architettura iniziale di riferimento</h4>
<p>Di seguito viene mostrata un'immagine che rappresenta l'architettura finale dello sprint precedente, che sarà quindi l'architettura iniziale di questo sprint.<br/>
<a href="img/architetturaIniziale.png">
	<img src="img/architetturaIniziale.png" name="Image1" align="bottom" width="1000" height="800" border="1"/>
</a>
<a href="img/architetturaIniziale.png">
</a>
</p>

<h2>GOAL</h2>
<p>In questo SPRINT verranno affrontati i seguenti requisiti:
<ul>
	<li>Definizione della ServiceStatusGUI</li>
	<li>Interazione WIS - ServiceStatusGUI</li>
</ul> 
</p>

<h2>Analisi del problema</h2>
<h4>Definizione della ServiceStatusGUI</h4>
<p>I requisiti specificano che la ServiceStatusGUI deve essere un'interfaccia grafica che permetta ad un utente di monitorare la situazione del sistema, in particolare:
<ul>
	<li>visualizzare lo stato del <b>WasteStorage</b>, come numero di RP attualmente presenti.</li>
	<li>visualizzare lo stato del <b>AshStorage</b>, come livello di capacità attualmente raggiunto.</li>
	<li>visualizzare lo stato del <b>Incinerator</b>, in termini di "sta bruciando oppure no".</li>
	<li>visualizzare lo stato del <b>OpRobot</b>, indicando la sua posizione corrente nell'area di servizio e il lavoro che sta effettuando.</li>
</ul>
</p>

<h4>Interazione WIS - ServiceStatusGUI</h4>
<p>La principale problematica dell'interazione WIS - ServiceStatusGUI è come far arrivare le info del sistema WIS alla GUI.<br>
Il problema contrario non si pone, in quanto la ServiceStatusGUI è un componente di sola lettura e non è richiesto che invii informazioni per aggiornare il sistema.<br>
I possibili modi per recuperare tali informazioni sono:
<ul>
	<li>rendere il WIS osservabile dalla GUI.</li>
	<li>far iscrivere la GUI al broker MQTT definito nello sprint precedente e recuperare le informazioni direttamente da lì.</li>
</ul>
Partiamo analizzando la soluzione di tipo publish/subscribe di MQTT.<br>
Facendo riferimento al "progetto" dello sprint precedente, le informazioni recuperabili dal broker sono soltanto lo stato del Incinerator, del ashStorageLevel e dell'arrivo di un nuovo RP.<br>
Per sfruttare tale soluzione, si dovrebbero aggiungere nuove publish per gestire anche lo stato del OpRobot.<br><br>

La soluzione di osservabilità del WIS da parte della GUI non necessita di ulteriori iscrizioni al broker, in quanto ci basta osservare le info del WIS.<br>
In pratica, lasciamo al WIS la responsabilità di ottenere le varie informazioni del sistema (tramite il broker) e la GUI non fa altro che osservare tali info.<br><br>

Entrambe le soluzioni hanno i loro vantaggi/svantaggi e quindi lasciamo la scelta ai progettisti.
</p>

<h2>Progetto</h2>
<p>
Ora ci vogliamo focalizzare su quali tecnologie utilizzare per la definizione dell'interfaccia.<br>
Le principali soluzioni che possono fare al caso nostro sono:
<ul>
	<li>Applicazione mobile (Android/IOS)</li>
	<li>Applicazione WEB</li>
</ul>
La definizione di un'applicazione mobile può essere interessante, ma richiede molto lavoro, in particolare per l'ottenimento delle informazioni dagli attori Qak sui vari nodi del sistema.<br>
<mark>Definire un'applicazione WEB ci permette di proporre una soluzione in minor tempo, 
soprattutto se utilizzando tecnologie a container come <a href="https://spring.io"/><b>Spring</b></a>.</mark><br/>
Il principale vantaggio delle tecnologie a container è che ci permettono di demandare al container tutta la parte "di contorno" per la gestione del supporto dei servizi di sistema (ad esempio, attivazione/disattivazione del server, gestione della sessione, ecc.)
e quindi evitare al programmatore il cosiddetto "boilerplate" code.<br>
In particolare, Spring è a container leggero, ovvero non è necessario caricare l'intero "pacchetto" ma si possono scegliere soltanto i moduli che ci interessano. (framework modulare. Architettura a layer, possibilità di utilizzare anche solo alcune parti in isolamento)<br>
Infine, il punto di forza principale di Spring è la <b>Dependency Injection</b>, ovvero la possibilità di ottenere una risorsa senza effettuare il binding a mano,
ma essa viene fornita in automatico dal container.<br>
Dunque, il container si occupa di risolvere (injection) le dipendenze dei componenti attraverso l’opportuna configurazione dell’implementazione dell’oggetto (push);
opposta ai pattern più classici di istanziazione di componenti o Service Locator, dove è il componente che deve determinare l’implementazione della risorsa desiderata.
</p>
<p>
	<h3>Struttura della wisFacade</h3>
	L'applicazione spring in questione è composta da una parte di backend e da una di frontend (per la quale si è deciso di adottare come 
	protocollo di comunicazione le websocket, in quanto permettono di, tramite una sola connessione tcp, ricevere aggiornamenti in tempo reale 
	dal backend dell'applicazione senza bisogno di ricaricare l'intera pagina). <br>
	La wisFacade è stata strutturata su diversi componenti:
	<ul>
		<li><b>FacadeBuilder</b>: crea i componenti dell'applicazione</li>
		<li><b>FacadeController</b>: funge da entrypoint dell'applicazione</li>
		<li><b>ApplGuiCore</b>: a questo componente viene demandato lo smistamento dei messaggi dal broker ai client websocket</li>
		<li><b>WSHandler</b>: designato per l'interazione con i client web tramite websocket</li>
		<li><b>MqttFacadeClient</b>: pensato per l'interazione con il broker MQTT</li>
	</ul>
	Di seguito viene riportata un'illustrazione della GUI:<br>
	<img src="img/wisfacadegui.png" alt="GUI" />
</p>

<p>
	<h3>Interazione WIS-WISFacade</h3>
	Riguardo l'interazione tra WIS e WISFacade, si presentano due possibili protocolli di comunicazione:
	<ul>
		<li><b>MQTT (publish/subscribe)</b>: questo tipo di interazione permette di ottenere 
			un disaccoppiamento maggiore tra i nodi dell'applicazione e di apportare meno 
			modifiche allo sprint precedente</li>
		<li><b>COAP</b>: questo tipo di interazione permetterebbe di aumentare l'accoppiamento 
			tra il WIS e la facade (permettendo tra le altre cose di verificare in tempo reale 
			che il WIS non presenti guasti), ma costringerebbe ad un refactoring più sostanzioso 
			del modello Qak
		</li>
	</ul>
	Siccome un maggiore disaccoppiamento sarebbe preferibile (in quanto il funzionamento della facade
	non obbliga il WIS ad essere up and running), e si preferisce riutilizzare il più possibile 
	il lavoro già svolto, si è deciso di optare per la prima opzione.<br>
	<b>
		Rimane da discutere con il committente se la facade deve potersi accorgere (ad esempio
		tramite un meccanismo di timeout) se i nodi dell'applicazione stanno mandando regolarmente
		aggiornamenti riguardo il loro stato.
	</b>
</p>
<p>
	Per poter permettere l'utilizzo di questo paradigma sono comunque state necessarie alcune
	modifiche:
	<ul>
		<li><b>Lato Monitoring Device:</b> all'evento di tipo ashStorageState è stato aggiunto
			un secondo payload che indica il livello di riempimento dell' Ash Storage.
			Quindi, l'attore monitoringdevice invia aggiornamenti relativi al suo stato ogni 
			volta che vi sono variazioni nella distanza misurata. <br>
			Il modello aggiornato si può trovare <a href="../progetto/monitoringDevice/src/monitoringdevice.qak">qui</a>
		</li>
		<li><b>Lato scale:</b> dovendo l'interfaccia grafica monitorare il numero di RP presenti
			nel WasteStorage, gli aggiornamenti da parte della scale vengono ora fatti comunicando
			direttamente questo dato (a differenza di prima, che venivano inviati aggiornamenti
			che notificavano soltanto l'arrivo di un nuovo RP).<br>
			Il modello aggiornato si può trovare <a href="../progetto/scale/src/scale.qak">qui</a>
		</li>
		<li><b>Lato WIS:</b> sono stati introdotti due nuovi eventi (opRobotState e opRobotJob) 
			da inviare al broker MQTT a fronte di update dello stato dell'opRobot (HOME, WASTEIN, etc) 
			e del lavoro che sta svolgendo.<br>
			Inoltre, a livello di proxy si è deciso di introdurre un ulteriore attore ausiliario <b>raspberryinfocontroller</b>
			che permetta al WIS di ricevere sempre dati aggiornati: quest'ultimo ora effettua un updateResource 
			che notifichi chiunque sia iscritto che è pronto a prendere un nuovo RP.
			Ricevuto questo messaggio, raspberryinfocontroller può notificare l'arrivo di un RP
			al WIS, oppure comunicargli che l'Ash Storage è pieno. 
			Contestualmente a ciò, questo attore ausiliario mantiene lo stato aggiornato del 
			monitoring device, della scale, e del wis stesso, in modo tale da poterlo aggiornare
			nel momento in cui il WIS si trova nello stato iniziale di attesa.<br>
			Grazie all'introduzione di quest'entità, si è riusciti ad alleggerire i compiti
			del wis e a permettergli di ricevere aggiornamenti "up to date" e al momento giusto.
			Il modello aggiornato si può trovare <a href="../progetto/wis/src/WasteIncineratorService_progetto.qak">qui</a>
		</li>
	</ul>
	<mark>In funzione del deployment con docker, ma soprattutto per disaccoppiare il modello dai parametri
	di configurazione (come ad esempio l'indirizzo del broker mqtt), si è deciso di creare per ciascun
	contesto un file di configurazione e un corrispondente oggetto kotlin (ad esempio per il wis abbiamo
	creato <a href="../progetto/wis/src/main/resources/WISConfigReader.kt">WISConfigReader.kt</a>), 
	in modo tale che gli attori che necessitino di configurazione possano invocarlo per leggerle
	dal file di configurazione.</mark>
</p>
<p>
	<h3>Sicurezza dei dati</h3>
	Sarebbe stato incompleto non includere una discussione riguardo le misure di sicurezza 
	da predisporre, trattandosi di un'applicazione web accessibile dall'esterno.<br>
	In particolare, l'applicazione spring permette ai client di leggere lo stato dei nodi del
	sistema, ma non permette in alcun modo di ricevere messaggi dai client. Va sottolineato anche
	il fatto che i dati forniti dall'applicazione non sono da ritenersi sensibili.<br>
	In ogni caso, la mancanza di un meccanismo di autenticazione potrebbe permettere a malintenzionati
	di effettuare più facilmente attacchi di tipo DoS. 
	Inoltre, la mancanza di cifratura di messaggi potrebbe permettere a dei malintenzionati,
	tra le altre cose, di effettuare attacchi di tipo "man in the middle": questo consentirebbe
	loro di manomettere le informazioni che provengono dall'applicazione spring verso i client.<br>
	Riguardo questo specifico requisito di sicurezza si è deciso di demandare la questione al committente.
</p>
<p>
	<h3>RaspberryMockFacade</h3>
	Si è deciso di fornire anche un'alternativa per far partire l'applicazione senza necessariamente essere in possesso di un raspberry pi.
	Di conseguenza si è pensato ad un'applicazione grafica per poter mandare messaggi al broker MQTT sostituendo di fatto il monitoring device 
	e la scale.<br>
	L'interfaccia grafica fornita è la seguente:<br>
	<img src="img/raspberrymockgui.png" alt="GUI" /><br>
	Si noti come, per quanto riguarda lo stato dell'AshStorage, si è deciso di permettere agli utenti di specificare soltanto lo stato di riempimento, e non il livello 
	di cenere effettivo. Questa decisione è dovuta principalmente ad una maggiore facilità di utilizzo da parte dell'utente. Inoltre, facendo un parallelismo con la controparte 
	fisica, un osservatore in ogni istante riesce a percepire tangibilmente se l'AshStorage è pieno, vuoto oppure ad un livello intermedio, ma non l'esatta distanza percepita dal sonar.<br>
	Per realizzare l'applicazione si è deciso di usare spring, come del resto si è fatto per la wisfacade, per gli stessi motivi.<br>
	Si è deciso di integrare l'applicazione spring con un modello QAK. In questo modo si permette di avere un maggiore 
	disaccoppiamento tra la parte dell'interazione con l'utente (tramite spring) e la parte di interazione tra il nodo del mock 
	e il broker MQTT. <br>
	<h4>Il modello QAK</h4>
	Per quanto concerne il modello QAK le entità in gioco sono monitoringdevice e scale. Al fine di liberare questi due componenti dall'onere di dover comunicare con l'applicazione spring, 
	si è deciso di introdurre un apposito attore ausiliario raspberrymockproxy, al quale viene delegato questo compito.<br>
	Del resto, monitoringdevice e scale sono stati presi uguali ai loro corrispondenti fisici, ad eccezion fatta per il modo in cui il monitoringdevice aggiorna il livello dell'ashStorage.
	L'interfaccia grafica deve poter permettere all'utente di stabilire il livello di riempimento, ma non permette di specificare una stima del livello dell'ashStorage.
	Di conseguenza, il monitoringdevice invia lo stato di riempimento, e insieme il valore massimo corrispondente a quel determinato stato (se lo stato è "EMPTY" o "NORMAL" manda il livello corrispondente
	al contenitore vuoto. Se invece è "FULL" manda il livello corrispondente al contenitore pieno ).<br>
	Di seguito si trova il <a href="../progetto/raspberrymock/src/raspberrymock.qak">modello QAK</a>
	<h4>L'applicazione spring</h4>
	L'applicazione spring si struttura in modo simile al caso della wisfacade, ed è composta da:
	<ul>		
		<li><b>FacadeBuilder</b>: crea i componenti dell'applicazione</li>
		<li><b>FacadeController</b>: funge da entrypoint dell'applicazione</li>
		<li><b>ApplGuiCore</b>: a questo componente viene demandato l'aggiornamento agli altri client websocket e dell'attore raspberrymockproxy</li>
		<li><b>WSHandler</b>: designato per l'interazione con i client web tramite websocket</li>
	</ul>
	Riguardo l'applicazione spring stessa (anche se per il momento non lo si ritiene necessario, in quanto è stata pensata per essere utilizzata 
	a scopo di testing del sistema) andrebbe valutato in futuro un'opportuna politica di controllo degli accessi (in quanto l'accesso all'interfaccia 
	grafica consente di modificare lo stato del sistema).
</p>

<h2>Piano di test</h2>
<p>
Avendo a che fare con un'applicazione Spring, questa tecnologia ci da la possibilità di effettuare dei test automatizzati tramite l'annotazione @SpringBootTest; a tal proposito il test prevede di effettuare una richiesta GET verso il server che dovrà restituire la pagina html relativa alla RobotFacade.<br>
<ul>
<li><b>TestRobotFacade</b>: posizionarsi sulla directory /sprint3/progetto/wisFacade ed eseguire <b>./gradlew test</b><br/>
	Per visualizzare l'output del test aprire la pagina al seguente <a href="../progetto/wisFacade/build/reports/tests/test/classes/unibo.wisFacade.FacadeApplicationTests.html">link</a>.</li>
</ul>
</p>
<p>
Il test automatizzato può essere trovato <a href="../progetto/wisFacade/src/test/java/unibo/wisFacade/FacadeApplicationTests.java">qui</a>.
</p>

<h2>Deployment</h2>
<h3>Deployment con gradle</h3>
<p>Per poter provare questo primo prototipo del sistema, occorre
eseguire i seguenti componenti nel seguente ordine: 
</p>
<ol>
	<li>Ambiente di simulazione <b>VirtualRobot:</b> posizionarsi nella cartella
	it.unibo.virtualRobot2023, aprire un terminale e lanciare il comando <b>docker compose -f .\virtualRobot23.yaml up</b>;
	</li>
	<li><b>BasicRobot</b>: posizionarsi nella cartella unibo.basicrobot24, aprire un terminale e lanciare il comando <b>gradlew run</b>; 
	</li>
	<li><b>WasteIncineratorService</b>: posizionarsi nella cartella sprint2, aprire un terminale e lanciare il comando <b>gradlew run</b>; 
	</li>
</ol>
<p>
Contemporaneamente a quanto fatto per avviare il WIS, occorre avviare
dai due nodi diversi su cui risiedono rispettivamente la logica della
Scale e del MonitoringDevice i relativi contesti. Per farlo occorre:</p>
<ol start="4">
	<li>Creare un eseguibile sia per il MonitoringDevice che per la Scale eseguendo <b>./gradlew distZip</b>; </li>
	<li>Copiare il file zip generato su entrambi i raspberry;</li>
	<li>Unzippare il file e lanciare il file eseguibile della sottocartella <b>bin</b>.</li>
</ol>
<h3>Deployment con docker</h3>
Si è scelto di effettuare anche il deployment con docker in modo da ottenere una 
soluzione containerizzata, già pronta all'uso, che permettesse di disaccoppiare 
ulteriormente i vari nodi del sistema e che permettesse di introdurre degli aspetti
di sicurezza (come l'autenticazione e la cifratura con TLS dei messaggi tra i vari
contesti). 
Come prima cosa, per ogni entità coinvolta è stato creato un Dockerfile, che si può 
trovare nelle rispettive cartelle, nel quale si possono trovare maggiori istruzioni
su come fare build delle varie immagini.
Per ognuna delle immagini che si collegano al broker MQTT è stato predisposto
un opportuno supporto tramite stunnel che permettesse di effettuare mutua autenticazione
e di cifrare il traffico scambiato con il broker. In questo modo si riesce a proteggere
il sistema sia da tentativi di lettura da parte di utenti esterni dello stato
dei vari dispositivi, sia da tentativi di intrusione del sistema.
Una volta fatto questo, posizionarsi su sprint2/progetto/wis ed eseguire:<br/>
<b>docker-compose -f wis.yaml up</b><br/>
in modo da lanciare in una volta sola virtual robot, basic robot, mqtt broker, e wis.
Per avviare il monitoring device e la scale sul raspberry, scaricare le immagini di 
monitoringdevice e scale ed eseguire:<br/>
<b>docker-compose -f raspberry.yaml up</b><br/>
Chiaramente dopo aver trasferito il file raspberry.yaml e il file stunnel.conf.<br/>
Per far partire la versione del wis con i mock al posto del raspberry eseguire:<br/>
<b>docker-compose -f wis_mock.yaml up</b><br>
Alternativamente, in modo tale da poter effettuare il deployment direttamente sui nodi del sistema in maniera automatica, 
si potrebbe optare per uno strumento come docker swarm. Tra le altre cose, consentirebbe anche una cifratura del traffico 
tra i container senza che questa venga gestita all'esterno come viene fatta ora. 

<h2>Suddivisione dei compiti</h2>
<p>
<ol>
	<li><b>Analisi del problema:</b> tutti i membri hanno contribuito, in particolare per discutere i vantaggi/svantaggi delle soluzioni proposte.  
	</li>
	<li><b>Progettazione:</b> tutti i membri hanno contribuito, in particolare:
		<ul>
			<li>Tutti: discusso assieme i vantaggi/svantaggi dell'uso di un metodo publish/subscribe anziché updateResource.</li>
			<li>Bryan: ragionato su vantaggi/svantaggi di gui sviluppata come applicazione mobile/web e implementazione della pagina della GUI.</li>
			<li>Gabriele ed Emanuele: creazione/modifica dei componenti lato Facade e lato qak.</li>
			<li>Gabriele: creazione raspberrymockfacade e deployment</li>
		</ul>
	</li>
	<li><b>Testing:</b> piano dei test deciso assieme. L'effettiva realizzazione è stata affidata a Gabriele. </li>
</ol>
</p>

<h2>Sprint futuri</h2>
<p>Nel prossimo sprint si prevede di implementare il robot fisico. 
</p>
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
Bryan Bertoni : bryan.bertoni@studio.unibo.it <br>
Gabriele Daga : gabriele.daga@studio.unibo.it <br>
Emanuele D'Arsié : emanuele.darsie@studio.unibo.it <br><br>

GIT repo: https://github.com/bryanber102/TemaFinale24
</div>

</body>
</html>
