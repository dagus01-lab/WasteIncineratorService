<!DOCTYPE html>
<head>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css" crossorigin="anonymous">
		<script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"crossorigin="anonymous"></script> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="./commons/resources/styles/code.css">
        <!-- <script type="text/javascript" src="./commons/resources/scripts/myScripts.js"></script> -->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}

.slidekp{
    background-color: hsl(332, 77%, 86%);
    border-radius: 10px;
    border: 1px solid blue;
    font-size: 18px; 
    font-weight: bold;
    line-height: 1.5;
    padding: 3px
  } 
</style>

<title>Documento Sprint2</title>
</head>

<body>
<div id="top">
	<h1> WASTE INCINERATOR SERVICE - Sprint 2 </h1>
</div>

<div class="body"> 
<h2>Introduzione</h2>
<p>
Un'azienda intende realizzare un <b>WasteIncineratorService</b> per trattare i rifiuti bruciandoli 
e necessita di un servizio di sistema software (WIS) che controlli un robot (chiamato OpRobot) per spostare i rifiuti.
</p>

<h2>Requisiti</h2>
<p>Il seguente link porta al documento dei requisiti fornito dal
cliente. <br/>
<a href="TemaFinale24.html">Documento requisiti</a> 
</p>

<h2>Sprint precedente</h2>
<p>Il seguente link porta al documento dello SPRINT precedente, nel
quale si sono affrontati i requisiti sull'interazione WIS-OpRobot e
WIS/OpRobot-Incinerator.<br/>
<a href="../../sprint1/userDocs/docSprint1.html">SPRINT 1</a> 
</p>

<h4>Architettura iniziale di riferimento</h4>
<p>Di seguito viene mostrata un'immagine che rappresenta l'architettura finale dello sprint precedente, che sarà quindi l'architettura iniziale di questo sprint.<br/>
<a href="img/architetturaIniziale.png">
	<img src="img/architetturaIniziale.png" name="Image1" align="bottom" width="1000" height="800" border="1"/>
</a>
<a href="img/architetturaIniziale.png">
</a>
</p>

<h2>GOAL</h2>
<p>In questo SPRINT verranno affrontati i seguenti requisiti:
<ul>
	<li>Architettura del MonitoringDevice</li>
	<li>Interazione WIS - MonitoringDevice</li>
	<li>Interazione WIS - Scale</li>
</ul>
Si rimanda quindi al prossimo SPRINT la definizione della ServiceStatusGUI. 
</p>

<h2>Analisi del problema</h2>
<h4>Architettura del MonitoringDevice</h4>
<p>I requisiti specificano che il MonitoringDevice è composto da unSonar e da un Led e lavora su un RaspberryPi, quindi un nodo esterno a quello in cui è presente il WIS.<br/>
Per rappresentare il sonar fisico e il led fisico, sfruttiamo quanto ci viene fornito dalla nostra software house.<br/>
In particolare, rappresentiamo il sonar attraverso il componente <a href="RaspApplCode24.html"><b>sonar24qak</b></a> che sappiamo essere composto da due attori: 
<ul>
	<li><b>sonardevice</b> che si occupadi leggere i dati generati dallo script <a href="sonar.py"><b>sonar.py</b></a>.
	Tale script non fa altro che rilevare continuamente dati dal sonar fisico presente nel RaspberryPi. 
	</li>
	<li><b>datacleaner</b> che riceve i valori letti dal sonardevice e si occupa di effettuare un ulteriore filtraggio sui dati. 
	</li>
</ul>
Il comportamento del led fisico verrà gestita da un altro attore <b>led</b> che dovrà richiamare alcuni script python per l'accensione, spegnimento e lampeggiamento del led fisico.<br/>
<br/>
Il MonitoringDevice verrà quindi visto dall'esterno come un unico componente (che internamente è composto dagli attori appena descritti), le cui interazioni con il WIS verranno discusse di seguito. 
</p>

<h4>Interazione WIS - MonitoringDevice</h4>
<p>Le principali problematiche dell'interazione WIS - MonitoringDevice sono le seguenti: 
<ul>
	<li>
		<span class="slidekp">P1</span>
		Quando il MonitoringDevice rileva che l'ashStorage è pieno, come notifica tale informazione al WIS? 
	</li>
	<li>
		<span class="slidekp">P2</span>
		Come capire quando l'ashStorage è vuoto? 
	</li>
	<li>
		<span class="slidekp">P3</span>
		lo stato dei componenti del WIS è conosciuto anche al MonitoringDevice o quest'ultimo deve esplicitamente chiedere tale informazione al WIS? 
	</li>
</ul>
<br>
Incominciamo analizzando il problema P1.<br/>
Da requisiti sappiamo che quando l'AshStorage è pieno, e finché l'operatore esterno non lo svuota, il WIS deve impedire che vengano bruciati altri RP.<br/>
La scelta più adatta e coerente a quanto descritto nello SPRINT1 (attraverso il mok del MonitoringDevice) è <mark>rendere il
WIS un Observer del MonitoringDevice, in particolare dell'informazione sullo stato del AshStorage</mark>.<br/>
Quando il datacleaner del MonitoringDevice rileva una distanza minore o uguale a DLIMT, allora il container è da considerare pieno e quindi aggiorna lo stato.<br/>
<br/>
Ora consideriamo il problema P2.<br/>
Capire quando l'AshStorage è vuoto, è più complicato di vedere quando è pieno, in quanto non viene fornito dai requisiti un parametro sulla
distanza da rilevare per considerarlo vuoto.<br/>
Una possibile soluzione è considerarlo vuoto all'avvio del sistema e ogni volta che viene svuotato dall'operatore esterno.<br/>
Un altro modo è introdurre un parametro nel sistema, per il momento costante ma che negli SPRINT successivi può essere impostato dall'utente (ad esempio
attraverso la GUI), che indichi la distanza tra il sonar e il fondo del contenitore, così se viene rilevata dal sonar tale distanza, si può considerare l'AshStorage vuoto.<br/>
<br/>
Infine discutiamo il problema P3.<br/>
Al MonitoringDevice l'unico componente del WIS che gli interessa realmente è l'Incinerator, in particolare sapere se sta bruciando o meno per accendere o spegnere il led di conseguenza.<br/>
Il modo migliore per ottenere tale informazione è far si che <mark>il MonitoringDevice diventi un Observer dell'Incinerator</mark>, evitando quindi uno scambio di messaggi poco utili tra WIS e MonitoringDevice. 
</p>

<h4>Interazione WIS - Scale</h4>
<p>Le problematiche relative all'interazione WIS - Scale sono le seguenti: 
<ul>
	<li>
		<span class="slidekp">P4</span>
		Come calcolare il numero di RP dal peso rilevato dalla scale fisica?
	</li>
	<li>
		<span class="slidekp">P5</span>
		Come comunicare tale informazione al WIS? 
	</li>
</ul>
<br/>
Partiamo analizzando il problema P4.<br/>
La principale
difficoltà sta nella conversione del peso rilevato dalla scale fisica in numero di RP, 
in quanto ci viene specificato dai requisiti che un RP è circa <b>WRP = 50 kg</b>, ma questo circa, unito all'errore fisico, potrebbe portare a misurazioni errate.
<br/>
Inoltre, l'errore di misura può variare da bilancia a bilancia, quindi in questa prima fase di analisi si decide di semplificare la realtà, considerando un arrotondamento &quot;secco&quot;
per difetto su WRP per calcolare il numero di RPs misurati: 
<b>RPs = W/WRP</b> con W peso rilevato dalla scale fisica. <br/>
<br/>
Consideriamo ora il problema P5.<br/>
Una volta ottenuto il numero di RPs presenti nel WasteStorage, occorre comunicare tale informazione al WIS.<br/>
<mark>Un possibile approccio, simile a quanto fatto con il MonitoringDevice, è rendere la scale osservabile e farla osservare dal WIS.<br/>
Tuttavia, per sfruttare quanto fatto negli sprint precedenti, si decide di comunicare il numero di RPs nel modo seguente:</mark>
<ol>
	<li>l'attore scale, dopo aver convertito da peso a numero di RP, calcola soltanto la differenza con il numero di RP precedenti. </li>
	<li>sempre l'attore scale manda un Dispatch <b>arrived_rp</b>, per ciascuna unità calcolata, al WIS.</li>
	<li>l'attore WIS, per capire se sono presenti o meno degli RPs, non fa altro che consumare i messaggi arrived_rp dalla propria coda di messaggi ricevuti. </li>
</ol>
Grazie a questo approccio, non dobbiamo toccare l'architettura del
WIS, e quindi dover aggiungere una variabile lato WIS che memorizzi
il numero di RPs, e inoltre sfruttiamo appieno la gestione della coda
dei messaggi di cui sono dotati gli attori qak. 
</p>

<h4>Architettura logica del problema</h4>
<p>Definiamo ora un modello, composto da tre file distinti .qak, che descrive come i componenti elencati in precedenza interagiscono tra loro: 
<ul>
	<li>
		<a href="../analisi_problema/wis/src/WasteIncineratorService_problema.qak"><b>WIS</b></a><br/>
		<a href="img/waste_incinerator_problem_servicearch.png">
			<img src="img/waste_incinerator_problem_servicearch.png" name="Image2" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
	<li>
		<a href="../analisi_problema/monitoringDevice/src/monitoringdevice.qak"><b>MonitoringDevice</b></a><br/>
		<a href="img/monitoringdevice_problem_arch.png">
			<img src="img/monitoringdevice_problem_arch.png" name="Image3" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
	<li>
		<a href="../analisi_problema/scale/src/scale.qak"><b>Scale</b></a><br/>
		<a href="img/scale_problem_arch.png">
			<img src="img/scale_problem_arch.png" name="Image4" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
</ul>
<span class="slidekp">Discussione sulle entità</span>
<br/>
Notiamo, come già descritto nell'analisi sull'architettura del MonitoringDevice, che il monitoringdevice delega i vari compiti al sonardevice, 
datacleaner e led, mostrandosi come unico componente verso l'esterno.<br/>
In particolare, il datacleaner ha il compito di pulire i tanti dati ricevuti dal sonardevice e inviare un <b>ashStorageLevel</b> al monitoringdevice 
che aggiorna <b>statoAshStorage</b> di conseguenza, in base al parametro ricevuto. (0 - vuoto, 1 - nè pieno nè vuoto, 2 - pieno)<br/>
Ricordiamo che statoAshStorage può essere 0 = non pieno o 1 = pieno, in quanto al WIS non interessa l'informazione di quando è vuoto.<br/>
<br/>
Configurazione simile la abbiamo per la Scale, che delega il raccoglimento delle misurazioni a scaledevice. Dopodichè, la scale effettua la
conversione dei dati e l'invio al WIS come descritto in precedenza. 
</p>

<p>
<h2>Progetto</h2>
<p>
<mark>Mentre nella sezione di analisi del problema si è deciso di modellare l'interazione tra MonitoringDevice e WIS e tra scale e WIS con il meccanismo
di observeResource</mark> in quanto più coerente con i requisiti dati dal committente, <mark>in questa fase si è deciso di optare per una comunicazione di tipo
publish/subscribe</mark>, in cui ogni qualvolta un dispositivo in un contesto deve comunicare con un dispositivo in un altro contesto emette un evento ad un
broker mqtt, che si occuperà di girarlo al contesto giusto. <mark>In questo modo si riesce a disaccoppiare i singoli contesti, che quindi possono
effettivamente "funzionare" indipendentemente dagli altri.</mark><br/>
</p>
<p>
Si pone ora un problema: supponiamo che il monitoringDevice aggiorni il suo stato di riempimento. Se il wis non fosse nello stato giusto per ricevere
l'evento inviato dal monitoringDevice tramite MQTT, quest'ultimo andrebbe perso. A tal scopo (oltre all'obiettivo di disaccoppiare il più possibile
le responsabilità degli attori) si è deciso che in ogni contesto, per ogni tipo di evento ricevuto tramite MQTT, vi siano degli appositi attori "proxy"
che si occupino di ricevere questi eventi e ritrasmetterli sotto forma di dispatch:
<ul>
<li><b>WIS</b>: può ricevere aggiornamenti sia da parte del monitoringDevice che da scale. Di conseguenza, vengono creati gli attori:
	<ul>
	<li><b>wismonitoringdeviceproxy</b>: riceve eventi di tipo statoAshStorage e invia al WIS dispatch di tipo ashesLevel</li>
	<li><b>wisscaleproxy</b>: riceve eventi di tipo new_RP e invia al WIS dispatch di tipo arrived_RP</li>
	</ul>
</li>
<li><b>monitoringDevice</b>: può ricevere aggiornamenti da parte di incinerator. Viene quindi creato l'attore <b>monitoringdeviceproxy</b> per ricevere
eventi di tipo statoIncinerator e inviare dispatch di tipo incineratorState al monitoringDevice.</li>
</ul><br/>
</p>
<p>
Inoltre, nel caso particolare del monitoringDevice, si è discusso molto il fatto che adottando questo approccio non si riuscirebbe a capire in maniera
diretta se quest'ultimo stia funzionando correttamente e se sia ancora connesso al broker (a differenza dell'approccio adottato in fase di analisi,
che garantirebbe, grazie al fatto che i contesti sono collegati tra loro, che in caso di scollegamento di una parte le altre siano in qualche modo
notificate). In effetti, si è concluso che se il monitoringDevice non riuscisse più a comunicare con il wis per qualsiasi motivo, quest'ultimo non
dovrebbe essere in grado di continuare con la sua esecuzione. Di conseguenza, in modo tale da non rinunciare al disaccoppiamento offerto dalla modalità
publish/subscribe, si è deciso di fare in modo che il monitoringDevice invii comunque lo stato di riempimento dell'ashStorage ogni 10 secondi nel caso
in cui non vi fossero aggiornamenti. Dal lato del wis, se non vi sono aggiornamenti da parte del monitoringDevice da più di 10 secondi, ci si posiziona
in uno stato di stallo fintantoché non arrivino nuovi aggiornamenti.<br/>
</p>
Di seguito si trovano i modelli aggiornati: 
<ul>
	<li>
		<a href="../progetto/wis/src/WasteIncineratorService_progetto.qak"><b>WIS</b></a><br/>
		<a href="img/waste_incinerator_progetto_servicearch.png">
			<img src="img/waste_incinerator_progetto_servicearch.png" name="Image2" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
	<li>
		<a href="../progetto/monitoringDevice/src/monitoringdevice.qak"><b>MonitoringDevice</b></a><br/>
		<a href="img/monitoringdevice_progetto_arch.png">
			<img src="img/monitoringdevice_progetto_arch.png" name="Image3" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
	<li>
		<a href="../progetto/scale/src/scale.qak"><b>Scale</b></a><br/>
		<a href="img/scale_progetto_arch.png">
			<img src="img/scale_progetto_arch.png" name="Image4" align="bottom" width="1000" height="800" border="1"/>
		</a>
	</li>
</ul>
</p>
<h3>Dispositivi utilizzati</h3>
<img alt="raspberrypins" src="Raspberry-Pi-GPIO-Layout-Model-B-Plus.png"></img><br>
Entrambi i dispositivi "esterni" (scale e monitoringDevice) sono pensati per essere eseguiti su raspberry Pi. Di seguito viene illustrato come sono stati
montati:
<ul>
<li><b>monitoringDevice</b>: il monitoringDevice è composto da un led e da un sonar HC-SR04. Per poter pilotarli vengono predisposti i seguenti script: <a href="../progetto/monitoringDevice/resources/ledDevice.py">ledDevice.py</a>, <a href="../progetto/monitoringDevice/resources/sonar.py">sonar.py</a> Coerentemente con quanto imposto dagli script, occorre montare i dispositivi nel modo seguente ad un raspberry Pi:
<ul>
<li><b>led</b>: collegare l'anodo (gambo lungo, +) al GPIO pin BCM25 (fisico 22) e il catodo (gambo corto, -) a GND (fisico 20)</li>
<li><b>sonar</b>: collegare:
	<ol>
	<li>VCC al pin fisico 4 </li>
	<li>GND al pin fisico 6 </li>
	<li>TRIG al pin fisico 11 </li>
	<li>ECHO al pin fisico 13 </li>
</li>
</ul>
</li>
<img alt="monitoringDevice" src="monitoringDevice.jpg"></img><br>
<li><b>scale</b>: la scale è composta da una load cell e <a href="hx711_datasheet.pdf">un convertitore AC/DC hx711</a>. Per poter leggere il peso dalla
bilancia viene predisposto lo script <a href="../progetto/scale/resources/scaleDevice.py">scaleDevice.py</a></li>. Coerentemente con quanto imposto
dallo script, occorre collegare i dispositivi nel modo seguente:
<ul>
<li>hx711 e raspberry:
<ul>
<li>VCC al pin fisico 4</li>
<li>SCK al pin fisico 18</li>
<li>DT al pin fisico 16</li>
<li>GND al pin fisico 9</li>
</ul>
</li>
<li>hx711 e scale:
<ul>
<li>E+: filo rosso</li>
<li>E-: filo nero</li>
<li>A-: filo verde</li>
<li>A+: filo bianco</li>
</ul>
</li>
</ul>
<img alt="scale" src="scaleDevice.jpg"></img><br>
</ul>
<h2>Piano di test</h2>
<p>
Dovendo avere a che fare con dispositivi di input che devono comunicare tra di loro su contesti diversi, si è pensato che il test automatizzato
dovesse prevedere di verificare che arrivino effettivamente messaggi di ogni dispositivo sul broker MQTT. In particolare, per ogni attore coinvolto,
si è deciso di effettuare un test che verifichi che entro un lasso di tempo di 20 secondi dall'avvio del WIS, non vengano ricevuti aggiornamenti.
Gli attori in questione sono:
<ul>
<li><b>MonitoringDevice</b>: emette già eventi periodici al massimo ogni 10 secondi</li>
<li><b>Scale</b>: emette un evento soltanto quando arrivano nuovi pacchetti. Si è deciso di modificarlo in modo tale che, se entro un intervallo di
10 secondi non vi sono aggiornamenti, si invia un evento new_RP con payload 0 (che verrà scartato dal proxy dal lato del WIS)</li>
</ul>
</p>
<p>
Il test automatizzato può essere trovato <a href="../progetto/wis/src/main/java/test/Test_Scale_MonitoringDevice.java">qui</a>.
</p>

<h2>Deployment</h2>
<p>Per poter provare questo primo prototipo del sistema, occorre
eseguire i seguenti componenti nel seguente ordine: 
</p>
<ol>
	<li>Ambiente di simulazione <b>VirtualRobot:</b> posizionarsi nella cartella
	it.unibo.virtualRobot2023, aprire un terminale e lanciare il comando <b>docker compose -f .\virtualRobot23.yaml up</b>;
	</li>
	<li><b>BasicRobot</b>: posizionarsi nella cartella unibo.basicrobot24, aprire un terminale e lanciare il comando <b>gradlew run</b>; 
	</li>
	<li><b>WasteIncineratorService</b>: posizionarsi nella cartella sprint2, aprire un terminale e lanciare il comando <b>gradlew run</b>; 
	</li>
</ol>
<p>
Contemporaneamente a quanto fatto per avviare il WIS, occorre avviare
dai due nodi diversi su cui risiedono rispettivamente la logica della
Scale e del MonitoringDevice i relativi contesti. Per farlo occorre:</p>
<ol start="4">
	<li>Creare un eseguibile sia per il MonitoringDevice che per la Scale eseguendo <b>./gradlew distZip</b>; </li>
	<li>Copiare il file zip generato su entrambi i raspberry;</li>
	<li>Unzippare il file e lanciare il file eseguibile della sottocartella <b>bin</b>.</li>
</ol>

<h2>Suddivisione dei compiti</h2>
<p>
<ol>
	<li><b>Analisi del problema:</b> tutti i membri hanno contribuito, in particolare: 
		<ul>
			<li>Bryan: concentrato principalmente sull'interazione WIS - MonitoringDevice.</li>
			<li>Gabriele: concentrato principalmente su Interazione WIS - Scale.</li>
			<li>Emanuele: concentrato principalmente sull'Architettura del MonitoringDevice.</li>
		</ul>
	Alla fine delle singole analisi, si è fatto una piccola revisione interna per discutere assieme dei punti analizzati e modificarli/validarli. 
	</li>
	<li><b>Definizione del modello:</b> tutti i membri hanno contribuito, in particolare: 
		<ul>
			<li>Bryan: modifica del WIS, in particolare per ricevere gli updateResource da contesti esterni, e supporto nell'interazione tra i componenti. </li>
			<li>Gabriele ed Emanuele: logica della scale + logica del monitoringdevice. </li>
		</ul>
	In questa fase di modellazione, si sono fatte diverse riunioni per allinearci sui problemi/soluzioni riscontrati durante lo sviluppo. 
	</li>
	<li><b>Progettazione:</b> tutti i membri hanno contribuito, in particolare:
		<ul>
			<li>Tutti: discusso assieme i vantaggi/svantaggi dell'uso di un metodo publish/subscribe anziché updateResource.</li>
			<li>Emanuele e Gabriele: montaggio fisico dei componenti sui due RaspberryPi e modifiche al codice dei componenti.</li>
		</ul>
	</li>
	<li><b>Testing:</b> piano dei test deciso assieme. L'effettiva realizzazione è stata affidata a Gabriele. </li>
</ol>
</p>

<h2>Sprint futuri</h2>
<p>Nel prossimo sprint si prevede di implementare la ServiceStatusGUI. 
</p>
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
Bryan Bertoni : bryan.bertoni@studio.unibo.it <br>
Gabriele Daga : gabriele.daga@studio.unibo.it <br>
Emanuele D'Arsié : emanuele.darsie@studio.unibo.it <br><br>

GIT repo: https://github.com/bryanber102/TemaFinale24
</div>

</body>
</html>
