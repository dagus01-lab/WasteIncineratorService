/** Modello per l'architettura logica dello SPRINT2 del WasteIncineratorService */

System waste_incinerator_service

//Messaggio per la ricezione di un nuovo RP
Event new_RP : new_RP(N) "event that simulates the arrival of a new RP"
Dispatch arrived_RP : arrived_RP(N) 

//Messaggio per notificare lo stato del Incinerator al WIS
Event statoIncinerator : statoIncinerator(N)  "Incinerator's burning status info: 0 is not burning, 1 otherwise"

//Messaggi per la gestione del burning dell'Incinerator
Dispatch activationCommand : activationCommand(N) "command that turns the incinerator on"
Dispatch startBurning : startBurning(N) "command that makes the incinerator start burning the next RP"
Dispatch rpInBurnin : rpInBurnin(N)  "command that makes the wis start the incinerator"
Event 	 endBurning : endBurning(N) "event generated by the incinerator when the burning process is terminated"
 
Event alarm : alarm(X)

//Messaggio per notificare la fine del percorso del OpRobot.
Dispatch newAshes : newAshes(N) "command that simulate the arrival of new RP's ashes"

//Messaggio per notificare lo stato del AshStorage al WIS
Dispatch ashesLevel : ashesLevel(N) "Event that simulates the level of the ashstorage container"
Event statoAshStorage : statoAshStorage(N)  "AshStorage info: 0 is not empty, 1 otherwise"

//Messaggio per notificare al wis che il monitoringDevice non sta più mandando aggiornamenti o che è ripartito
Dispatch monitoringDeviceRuns:monitoringDeviceRuns(N) "message that represents the level of the ash storage (1 if it is up, 0 otherwise)"

//Messaggi per ingaggiare e muovere il BasicRobot
Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage 
Dispatch disengage    : disengage(ARG) 

Request moverobot    :  moverobot(TARGETX, TARGETY)   
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot

//Definizione dei contesti
Context ctx_waste_incinerator_service ip [host="localhost" port=8125]
Context ctxbasicrobot ip [host="127.0.0.1" port=8020] 

//Attori esterni al WIS
ExternalQActor basicrobot context ctxbasicrobot
//--------------------------------Attori WIS-proxy-----------------------------------------------------------
QActor wisscaleproxy context ctx_waste_incinerator_service{
	State s0 initial{
		connectToMqttBroker "tcp://localhost:8081" clientid "wisscaleproxynat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "wisscaleproxynat"
 		println("$name | CREATED  (and connected to mosquitto) ... ") color magenta
 		subscribe "wisinfo"
		//si mette ad osservare lo stato del AshStorage fornito dal MonitoringDevice
	}
	Transition t0 whenEvent new_RP -> handle_new_RP
	State handle_new_RP{
		onMsg(new_RP:new_RP(N)){
			[#
				try{
					var Status = payloadArg(0).toInt()
			#]
			if[#Status>0#]{
				forward wis -m arrived_RP:arrived_RP(1)
			}
			[#
				} catch(e:Exception){
					#]println("$name received invalid payload:${payloadArg(0)}") color red[#
				}
			#]
		}
	}
	Transition t0 whenEvent new_RP -> handle_new_RP
}

QActor wismonitoringdeviceproxy context ctx_waste_incinerator_service{
	[#
		var timeoutExpired = true;
		var Status = 0;
		var previousStatus = 0;
	#]
	State s0 initial{
		connectToMqttBroker "tcp://localhost:8081" clientid "wismonitoringdeviceproxynat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "wismonitoringdevicenat"
 		println("$name | CREATED  (and connected to mosquitto) ... ") color cyan
 		delay 1000
 		subscribe "wisinfo"
		//si mette ad osservare lo stato del AshStorage fornito dal MonitoringDevice
	}
	Goto wait
	State wait{
		
	}
	Transition t0 	whenTime 15000 -> handleTimeoutExpired
					whenEvent statoAshStorage -> handleUpdateStatoAshStorage
	State handleUpdateStatoAshStorage{
		onMsg(statoAshStorage:statoAshStorage(N)){
			[#
				if(timeoutExpired){
					timeoutExpired = false
					#]
						forward wis -m monitoringDeviceRuns:monitoringDeviceRuns(1)
					[#
				}
				try{
					var Status = payloadArg(0).toInt()
			#]
			if[#Status>=0 && Status != previousStatus#]{
				forward wis -m ashesLevel:ashesLevel($Status)
			}
			[#	
				previousStatus=Status
				}catch(e:Exception){
					#]println("$name received invalid payload:${payloadArg(0)}") color red[#
				}
			#]
			
		}
	}
	Goto wait
	
	State handleTimeoutExpired{
		[#timeoutExpired = true#]
		forward wis -m monitoringDeviceRuns:monitoringDeviceRuns(0)
	}
	Goto wait
}

//--------------------------------Attore WIS-----------------------------------------------------------------
QActor wis context ctx_waste_incinerator_service{
	[# 
		var AshStorageStatus = 0 
		var RPs = 0
		var monitoringDeviceRunning = 0
	#]
	
	State s0 initial{
		delay 500
		println("$name STARTS") color green
		//mando messaggio di attivazione del Incinerator
		forward incinerator -m activationCommand : activationCommand(1)
		delay 8000
	}
	Goto waitingRP
	
	//Stato che simula l'attesa di un nuovo RP nel WasteStorage
	State waitingRP{
	}
	Transition t0 whenMsg monitoringDeviceRuns -> handleMonitoringDeviceRunningStatus
				  whenMsg ashesLevel-> handleUpdateAshesLevel
				  whenMsg arrived_RP ->  handleRP
				  
				  
	
	//Stato per gestire gli aggiornamenti sullo stato di esecuzione del monitoring device
	State handleMonitoringDeviceRunningStatus{
		onMsg(monitoringDeviceRuns:monitoringDeviceRuns(N)){
			[#monitoringDeviceRunning=payloadArg(0).toInt()#]
		} 
	}
	Transition t0 whenTime 1000 -> ackMonitoringDeviceRunningStatus //wait for every monitoringDeviceRunningStatus message to be read
				  whenMsg monitoringDeviceRuns -> handleMonitoringDeviceRunningStatus
	State ackMonitoringDeviceRunningStatus{
		
	}
	Goto waitForMonitoringDeviceToRun if [#monitoringDeviceRunning==0#] else waitingRP
	State waitForMonitoringDeviceToRun{
		println("$name waiting for monitoringDevice to run again") color red
	}
	Transition t0 whenMsg monitoringDeviceRuns -> handleMonitoringDeviceRunningStatus
	
	
	
	
	//Stato per gestire l'arrivo di un nuovo RP nel WasteStorage
	State handleRP{
		println("New RP is arrived") color green
		//notifico il robot che un nuovo RP è disponibile
		forward oprobot -m arrived_RP : arrived_RP(1)
	}
	Transition t0 whenMsg rpInBurnin -> handleRPInBurnin
	
	//Stato per gestire l'arrivo del opRobot nella porta di BURNIN del Incinerator
	State handleRPInBurnin{
		println("An RP is ready to be burnt") color green
		//mando messaggio di inizio burning al Incinerator
		forward incinerator -m startBurning : startBurning(1)
	}
	Transition t0 whenEvent endBurning -> handleEndBurning
	
	//Stato per gestire l'evento di endBurning
	State handleEndBurning{
		println("Incinerator has finished to burn") color green
	}
	Transition t0 whenMsg newAshes -> endRoute
	
	//Stato per gestire la "fine del giro" di scarico del robot
	State endRoute{
		println("$name OpRobot has finished its route") color green
		//se entro 1 secondo non ricevo aggiornamenti sullo stato del AshStorage, 
		//allora considero di poter bruciare un nuovo RP
	}
	
	Transition t0 whenTime 2000 -> waitingRP
				  whenMsg ashesLevel -> handleUpdateAshesLevel
		
		
		
							
	//Stato per gestire l'aggiornamento dello stato del AshStorage
	State handleUpdateAshesLevel{
		printCurrentMessage color green
		onMsg(ashesLevel : ashesLevel(N)){
			//println ("cifra stato: ${payloadArg(1).split('(')[1].split(')')[0]}") color green
			[# AshStorageStatus = payloadArg(0).toInt()#]
			println("AshStorageStatus: $AshStorageStatus") color green
		}
	}
	Transition t0 whenTime 2000 -> ashCheckFinish
				  whenMsg ashesLevel -> handleUpdateAshesLevel
	
	State ashCheckFinish{
		 
	}
	Goto waitingRP if [# AshStorageStatus == 0 #] else waitingAshesToBeRemoved
	
	//Stato per gestire l'attesa che la cenere nel AshStorage sia rimossa per poter bruciare nuovi RPs
	State waitingAshesToBeRemoved{
		println("WIS is waiting for an operator to remove ashes in AshStorage...") color green
	}
	Transition t0 whenMsg ashesLevel -> handleUpdateAshesLevel
}
//-----------------------------------------------------------------------------------------------------------

//----------------------------------------Attore OpRobot-----------------------------------------------------
QActor oprobot context ctx_waste_incinerator_service{
	[#	
		var HOMEx = 0
		var HOMEy = 0
		var WASTEINx = 0
		var WASTEINy = 4
		var BURNINx = 3
		var BURNINy = 2
		var BURNOUTx = 4
		var BURNOUTy = 3
		var ASHOUTx = 6
		var ASHOUTy = 4
	#]
	State s0 initial{
		println("$name STARTS") color yellow
	}
	Goto engage
	
	//Stato per provare ad "ingaggiare" il BasicRobot
	State engage{
		println("$name | $MyName engaging ... ") color yellow 
		request basicrobot -m engage : engage($MyName,330) //pc Emanuele 112
	}
	Transition t0 whenTime 1000 -> noResponse
				  whenReply engagedone   -> waitingWorking
 	              whenReply engagerefused -> end
 	          
 	//stato che rappresenta l'assenza di risposta da parte del basicrobot
 	State noResponse{
 		println("BasicRobot did not answer!") color yellow
 	}
 	Goto end
	
	//Stato che rappresenta il robot in attesa di lavoro
	State waitingWorking{
		println("$name is in HOME position waiting for working") color yellow
	}
	Transition t0 whenMsg arrived_RP -> takeRP
	
	//Stato che rappresenta il robot che va a recuperare un RP dal WasteStorage
	State takeRP{
		println("OpRobot is going to take an RP..") color yellow
		request basicrobot -m moverobot:moverobot($WASTEINx,$WASTEINy)
	}
	Transition t0 whenReply moverobotdone -> bringRPtoBURNIN
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che porta l'RP recuperato dal WasteStorage nella porta BURNIN
	State bringRPtoBURNIN{
		delay 2000 //simulazione del prelievo di un RP dal WasteStorage
		request basicrobot -m moverobot:moverobot($BURNINx, $BURNINy)
	}
	Transition t0 whenReply moverobotdone -> returnHOME
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta lo spostamento in HOME del robottino una volta che l'RP è stato messo nell'inceneritore
	State returnHOME{
		delay 2000 //simulazione del rilascio di un RP in BURNIN
		forward wis -m rpInBurnin : rpInBurnin(1)
		println("An RP is in BURNIN port") color yellow
		request basicrobot -m moverobot:moverobot($HOMEx, $HOMEy)
		//then, return HOME
	}
	Transition t0 whenReply moverobotdone -> waitingForIncinerator
				  whenReply moverobotfailed -> exit
				 
	//Stato che rappresenta l'attesa del incinerator che sta bruciando
	State waitingForIncinerator{
		println("Waiting for incinerator to finish its job") color yellow
	}
	Transition t0 whenEvent endBurning -> takeAshFromBURNOUT
	
	//Stato che rappresenta il robot che preleva la cenere dalla porta BURNOUT
	State takeAshFromBURNOUT{
		request basicrobot -m moverobot:moverobot($BURNOUTx, $BURNOUTy)
	}
	Transition t0 whenReply moverobotdone -> bringAshtoASHOUT
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che va a depositare la cenere raccolta dall'inceneritore
	State bringAshtoASHOUT{
		delay 2000 //simulo il prelievo della cenere da BURNOUT
		request basicrobot -m moverobot:moverobot($ASHOUTx, $ASHOUTy)
	}
	Transition t0 whenReply moverobotdone -> restartJob 
				  whenReply moverobotfailed -> exit
				  
	//Stato che rappresenta il robot che torna in HOME dopo aver scaricato le ceneri nell'AshStorage
	State restartJob{
		delay 2000 //simulo lo scaricamento della cenere
		println("The ash has been taken out") color yellow
		//mando notifica di nuova cenere
		forward wis -m newAshes : newAshes(1)
		request basicrobot -m moverobot:moverobot($HOMEx, $HOMEy)    
	}
	Transition t0 whenMsg arrived_RP -> takeRpBeforeFinishPlan
				  whenReply moverobotdone -> waitingWorking
				  whenReply moverobotfailed -> exit
	
	State takeRpBeforeFinishPlan{
		println("A new RP has arrived before OpRobot returned HOME") color yellow
		delay 500
		emit alarm:alarm(1) 
	}
	Transition t0 whenReply moverobotdone -> testko
				  whenReply moverobotfailed -> takeRP
	
	State testko{
		println("BasicRobot ignored alarm!!") color yellow
	}
	Goto takeRP
	
	//Stato di fine, nel caso l'engage del BasicRobot non fosse andata a buon fine
	State end{
		println("$name | ENDS ") color yellow
	}
	
	State exit{
		println("$name has been terminated") color yellow
	}
}
//-----------------------------------------------------------------------------------------------------------

//---------------------------------Attore Incinerator--------------------------------------------------------
QActor incinerator context ctx_waste_incinerator_service{
	[# val BTIME = 10000L; var stato = 0; #]
	
	State s0 initial{
		delay 1000
		println("$name STARTS") color red 
		connectToMqttBroker "tcp://localhost:8081" clientid "incineratornat"
		//connectToMqttBroker "tcp://test.mosquitto.org" clientid "incineratornat" 
 		println("$name | CREATED  (and connected to mosquitto) ... ") color green
	}
	Transition t0 whenMsg activationCommand -> turnOn
	
	State turnOn {
		println("Incinerator is on. Waiting for RPs to burn...") color red
	}
	Transition t0 whenMsg startBurning -> handleStartBurning
	
	//Stato per gestire l'inizio di burning
	State handleStartBurning{
		println("Incinerator is burning...") color red
		publish "wisinfo" -m statoIncinerator:statoIncinerator(1)
	}
	Transition t0 whenTimeVar BTIME -> handleEndBurning
	
	//Stato per gestire la fine di burning
	State handleEndBurning{
		emit endBurning : endBurning(1) //emette il segnale di fine burning
		publish "wisinfo" -m statoIncinerator:statoIncinerator(0)
	}
	Transition t0 whenMsg startBurning -> handleStartBurning   
}
//-----------------------------------------------------------------------------------------------------------

//-----------------------Attore mock che simula il comportamento della Scale---------------------------------
/*QActor scalemock context ctx_waste_incinerator_service{
	State s0 initial {
		println("$name STARTS") color black
	}//-----------------------------------------------------------------------------------------------------------
	Transition t0 whenTime 1000 -> simulateRP //l'attore simula l'arrivo di un RP dopo 1 secondo
	
	State simulateRP {
		delay 5000
		updateResource [#arrived_RP(1))#]
		//delay 38000
		//forward wis -m arrived_RP : arrived_RP(1)
	}
	Goto simulateRP
}*/

//-----------------------------------------------------------------------------------------------------------
/*
//------------------------Attore mok che simula il comportamento del MonitoringDevice------------------------
QActor monitoring_device_mok context ctx_waste_incinerator_service{
	[# var ashLevel = 3; val MAX_LEVEL = 4;  //livello delle cenere sotto forma di numero di RP bruciati
	 var statoAshStorage=0; #]
	State s0 initial{
		println("$name STARTS") color yellow
	}Goto emitState
	
	State emitState{
		updateResource [# "statoAshStorage(0)" #]
		delay 2000
	}
	Transition t0 whenMsg newAshes -> handleAshes
	
	//Stato per gestire l'arrivo di nuova cenere nel container
	State handleAshes{
		[# ashLevel ++ #]
		//Se il livello della cenere = MAX_LEVEL, allora non posso bruciare altri RP
		if [# ashLevel == MAX_LEVEL #]
		{
			println("AshStorage is full. It is not possible to burn new RPs.") color yellow
			updateResource [# "statoAshStorage(1)" #] //aggiorno gli Observer collegati
		}
		else
		{
			updateResource [# "statoAshStorage(0)" #] //aggiorno gli Observer collegati
		}
	}
	Transition t0 whenTime 40000   -> simulateRemoveAshes
				  whenMsg newAshes -> handleAshes
				  
	//Stato per simulare la svuotamento del container di cenere
	State simulateRemoveAshes{
		println("Removed ashes from AshStorage. Now the container is empty.") color yellow
		[# ashLevel = 0 #]
		updateResource [# "statoAshStorage(0)" #] //aggiorno gli Observer collegati
	}
	Transition t0 whenMsg newAshes -> handleAshes
}
//-----------------------------------------------------------------------------------------------------------
* */
